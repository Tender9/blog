## ⭐️功能需求

1. 员工数据按照年龄排序；

   ```js
   // 员工数据存储在一个数组中，每个员工对象包含姓名、年龄和职业属性
   const people = [
       { name: '张三', age: 28, occupation: '工程师' },
       { name: '李四', age: 24, occupation: '设计师' },
       { name: '王五', age: 30, occupation: '销售经理' },
   ];
   ```

2. 筛选24岁以上员工；

3. 提取到新的表格里，并组成文本

### 命令式编程

```js
// 1. 按年龄排序
for (let i = 0; i < employees.length - 1; i++) {
    for (let j = 0; j < employees.length - i - 1; j++) {
        if (employees[j].age > employees[j + 1].age) {
            const temp = employees[j];
            employees[j] = employees[j + 1];
            employees[j + 1] = temp;
        }
    }
}

// 2. 筛选24岁以上员工
const filteredEmployees = [];
for (let i = 0; i < employees.length; i++) {
    if (employees[i].age >= 24) {
        filteredEmployees.push(employees[i]);
    }
}

// 3. 提取到新的表格并组成文本
let text = "姓名\t年龄\t职业\n"; 
for (let i = 0; i < filteredEmployees.length; i++) {
    const employee = filteredEmployees[i];
    text += `${employee.name}\t${employee.age}\t${employee.occupation}\n`; 
}
console.log(text); 
```



### 函数式编程

```js
// 1. 按年龄排序
const sortedByAge = (a, b) => a.age - b.age;

// 2. 筛选24岁以上员工
const employeeBiggerThan24 = (v) => v.age >= 24;

// 3. 提取到新的表格并组成文本
const generateLogText = (v) => {
    return `${v.name}\t${v.age}\t\t${v.occupation}`;
};

let res = employees.sort(sortedByAge).filter(employeeBiggerThan24).map(generateLogText).join("\n");

let text = "姓名\t年龄\t职业\n" + res;
console.log(text);
```

JavaScript中具有声明式编程的方法包括了 `map`、`filter` 和 `reduce` 等

```js
// 1. 按年龄排序
const sortedEmployees = [...employees].sort((a, b) => a.age - b.age);

// 2. 筛选24岁以上员工
const filteredEmployees = sortedEmployees.filter((employee) => employee.age >= 24);

// 3. 提取到新的表格并组成文本
const text = filteredEmployees.map((employee) => `${employee.name}\t${employee.age}\t\t${employee.occupation}`).join("\n");

console.log("姓名\t年龄\t职业\n" + text);
```

整个过程中没有显式的循环，而是使用了函数式编程的方式来表达程序逻辑

### 副作用

函数在执行过程中产生了**外部可观察变化**

1. 修改全局变量或外部状态

   ```js
   let globalVariable = 10;
   
   function modifyGlobalVariable(newValue) {
       globalVariable = newValue;
   }
   
   console.log(globalVariable); // 输出: 10
   modifyGlobalVariable(20);
   console.log(globalVariable); // 输出: 20
   ```

2. 修改函数参数所引用的对象或数据结构

   ```js
   let obj = { value: 10 };
   
   function modifyObject(obj, newValue) {
       obj.value = newValue;
   }
   
   console.log(obj.value); // 输出: 10
   modifyObject(obj, 20);
   console.log(obj.value); // 输出: 20
   ```

   

3. 发送 HTTP 请求或执行数据库查询

   ```js
   function fetchDataFromServer() {
       // 发送 HTTP 请求并获取数据
   }
   
   fetchDataFromServer(); // 发送了 HTTP 请求，具有副作用
   ```

4. 打印输出到控制台或日志文件（输出了信息到外部环境，使得程序执行过程可观察）

   ```js
   function printMessage(message) {
       console.log(message); // 打印消息到控制台，具有副作用
   }
   
   printMessage("Hello, world!"); // 在控制台打印了 "Hello, world!"，具有副作用
   ```

5. 抛出异常或错误（异常的抛出会导致程序的执行流程发生改变，外部环境可观察到）

   ```js
   function divide(a, b) {
       if (b === 0) {
           throw new Error("除数不能为零");
       }
       return a / b;
   }
   
   divide(10, 0); // 抛出异常，具有副作用
   ```



### 纯函数

给定相同的输入，总是产生相同的输出 → 不会产生意外的副作用

1. 计算两个数的和

   ```js
   function add(a, b) {
       return a + b;
   }
   // 执行函数相同输入输出结果一致
   add(2,3)
   ```

PS：副作用并没有直接影响函数的纯度时，也可被视为一个纯函数

```js
function printMessage(message) {
    console.log(message);
}
printMessage("Hello, world!");
```

### 非纯函数

与外部环境产生了交互或影响，通常产生了副作用

1. 生成一个随机数

   ```js
   function generateRandomNumber() {
       return Math.random();
   }
   // 输出结果可能是不确定的
   console.log(generateRandomNumber()); // 输出: 0.12345
   console.log(generateRandomNumber()); // 输出: 0.54321
   ```

   每次调用都可能返回不同的值，因此它是一个非纯函数

   

2. 修改了全局变量

   ```js
   let counter = 0;
   function incrementCounter() {
       counter++;
   }
   
   // 调用非纯函数，会修改全局变量的状态
   incrementCounter();
   console.log(counter); // 输出: 1
   ```

   `rementCounter` 函数会修改外部的全局变量 `counter` 的状态，具有副作用，是一个非纯函数



3. 副作用影响函数以外的状态

   ```js
   let x = 10;
   
   function sum(a) {
       console.log(a + x);
   }
   
   sum(5);
   ```

   变量 `x` 改变，执行`sum(5)`时得到的输出发生改变

   PS：**但如果是`const` 声明 `x`，那它还是一个纯函数**

   

### 高阶函数

将一个函数作为参数传递给另一个函数

## ⭐️功能需求

记录某个函数执行了多少次

```js
let count = 0;

function bar() {
    console.log("hello");
    count++;
}

let count1 = 0;

function foo() {
    console.log("world");
    count1++;
}
```

简单封装为高阶函数

```js
function bar() {
    console.log("a");
}

function count(fn) {
    let count = 0;
    return [
        (...args) => {
            fn(...args);
            count++;
        },
        () => count
    ];
}

let [countByBar, countBarTimes] = count(bar);
countByBar();
countByBar(); 
console.log(countBarTimes()); // 2
```

### 使用高阶函数实现员工提取到表格

1. **链式调用**

   ```js
   // 按照年龄排序的比较函数
   function smallAgeFirst(a, b) {
       return a.age - b.age;
   }
   
   // 筛选出年龄大于等于24岁的员工
   function ageBiggerThan24(person) {
       return person.age >= 24;
   }
   
   // 生成文本信息的函数
   function generateLogText(person) {
       return `${person.name}\t${person.age}\t\t${person.occupation}`;
   }
   
   // 定义工作函数，实现员工数据按年龄排序、筛选24岁以上员工、提取并组成文本
   const work = (arr) => {
       return (
           "姓名\t年龄\t职业\n" +
           arr
               .sort(smallAgeFirst) // 按年龄排序
               .filter(ageBiggerThan24) // 筛选24岁以上员工
               .map(generateLogText) // 生成文本信息
               .join("\n")
       ); // 使用换行符连接文本信息
   };
   
   // 调用工作函数，得到结果并输出
   console.log(work(people));
   ```

   

2. **管道函数 pipe**

   ```js
   // 按照年龄排序的比较函数
   function sort(people) {
       return people.sort((a, b) => a.age - b.age);
   }
   
   // 筛选出年龄大于等于24岁的员工
   function filter(people) {
       return people.filter(person => person.age >= 24);
   }
   
   // 提取并组成文本信息的函数
   function map(people) {
       return people.map(person => `${person.name}\t${person.age}\t${person.occupation}`);
   }
   
   // 定义管道函数
   const pipe = (funcs) => {
       return (input) => {
           return funcs.reduce((pre, cur) => {
               return cur(pre);
           }, input);
       };
   };
   
   // 将操作函数放入管道中，并执行操作
   const work = pipe([sort, filter, map]);
   const result = work(people);
   
   // 输出结果
   console.log("姓名\t年龄\t职业");
   console.log(result.join("\n"));
   ```

   - `pipe` 函数接受一个函数数组 `funcs` 作为参数，并返回一个函数
   - 返回的函数接受一个输入 `input`，并通过 `reduce` 方法依次执行 `funcs` 数组中的函数，将每个函数的输出作为下一个函数的输入
   - 最终返回的函数就是一个将输入依次经过 `funcs` 数组中的函数处理后得到的结果（相当于链式调用）
   - 避免了中间变量的产生

   

3. **组合函数compose**

   ```js
   export const pipe = (funcs) => {
       const p = (input, fun) => fun(input);
       return (data) => funcs.reduce(p, data);
   };
   
   export const compose = (funcs) => {
       const p = (input, fun) => fun(input);
       return (param) => funcs.reduceRight(p, param);
   };
   ```

   

### 柯里化函数

#### 偏函数

函数参数有多个，但其中可以设置几个固定参数

```js
function add(a, b) {
    return a + b;
}

function sum(b) {
    return add(5, b);
}
```



#### 柯里化

简单函数柯里化

```js
function num(a, b, c) {
    return a * b * c;
}

👇

const createNum = (a) => {
    return (b) => {
        return (c) => {
            return a * b * c;
        };
    };
};
```

可以根据参数确定函数的个数

## ⭐️功能需求

写一个高阶函数，自动根据函数进行柯里化

```js
function num(a, b, c) {
    return a * b * c;
}

const curry = (fn, arg = []) => {
    return (input) => {
        // 将传入的参数添加到数组中
        arg.push(input);
        // 判断传入参数是否满足函数参数个数
        if (arg.length === fn.length) {
            return fn(...arg);
        }
        // 不满足则递归生成新的函数
        return curry(fn, arg);
    };
};

const f = curry(num);
console.log(f(1)(2)(3), "f"); // 输出 6

```





